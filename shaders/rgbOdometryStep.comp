#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D lastColorMap;
layout(binding = 1, rgba8) uniform image2D nextColorMap;

layout(binding = 2, rgba8) uniform image2D gradientMap;

layout(binding = 3, r16ui) uniform uimage2D lastDepthMap;
layout(binding = 4, r16ui) uniform uimage2D nextDepthMap;

layout(binding = 5, rgba32f) uniform image2D nextVertexMap; // is this next?


float FLT_EPSILON = 1.19209290E-07f;

uniform float sigma;
uniform float sobelScale;
uniform float depthScale;
uniform float minScale;
uniform vec4 kt;
uniform mat3 krkinv;
uniform float maxDepthDelta;
uniform vec4 cam; // cx cy fx fy

struct DataTerm
{
	ivec2 zero;
    ivec2 one;
    float diff;
    bool valid;
};

struct JtJJtrSE3
{
    // // 27 floats for each product (27)
    //float aa, ab, ac, ad, ae, af, ag,
    //          bb, bc, bd, be, bf, bg,
    //              cc, cd, ce, cf, cg,
    //                  dd, de, df, dg,
    //                      ee, ef, eg,
    //                          ff, fg;

	float data[27];

    //Extra data needed (29)
    float residual;
	float inliers;
};

struct rowSE3
{
	float data[7];
	float inliers;
};

layout(std430, binding = 0) buffer corresData
{
    DataTerm corresImg[];
};

layout(std430, binding = 0) buffer outputData
{
    rowSE3 outputBuffer[];
};

float luminance(vec3 rgb)
{
    return 0.299f * float(rgb.x) + 0.587f * float(rgb.y) + 0.114f * float(rgb.z);
}

void main()
{
	ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imSize = imageSize(lastColorMap);

	rowSE3 row;


	DataTerm corresp = corresImg[pix.y * imSize.x + pix.x];

	bool found_corresp = corresp.valid;

	if (found_corresp)
	{
		float w = sigma + abs(corresp.diff);

		w = w > FLT_EPSILON ? 1.0 / w : 1.0f;

		if (sigma == -1)
		{
			w = 1;
		}

		row.data[6] = -w * corresp.diff;

		vec3 cloudPoint = imageLoad(nextVertexMap, corresp.zero).xyz;

		float invZ = 1.0f / cloudPoint.z;

		vec2 dI_dxdy_val = w * sobelScale * imageLoad(gradientMap, corresp.one).xy;

		float v0 = dI_dxdy_val.x * cam.z * invZ;
		float v1 = dI_dxdy_val.y * cam.w * invZ;
		float v2 = -(v0 * cloudPoint.x + v1 * cloudPoint.y) * invZ;


		row.data[0] = v0;
        row.data[1] = v1;
        row.data[2] = v2;
        row.data[3] = -cloudPoint.z * v1 + cloudPoint.y * v2;
        row.data[4] =  cloudPoint.z * v0 - cloudPoint.x * v2;
        row.data[5] = -cloudPoint.y * v0 + cloudPoint.x * v1;


	}
	else
	{
	    row.data[0] = row.data[1] = row.data[2] = row.data[3] = row.data[4] = row.data[5] = row.data[6] = row.inliers = 0.f;
	}


	outputBuffer[pix.y * imSize.x + pix.x] = row;


}